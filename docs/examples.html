<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>image-stitch ‚Ä¢ Interactive Examples</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body {
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #0f172a;
      padding: clamp(1.5rem, 4vw, 3rem);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.96);
      border-radius: 24px;
      box-shadow: 0 35px 90px rgba(76, 29, 149, 0.35);
      overflow: hidden;
    }

    header {
      padding: clamp(2rem, 6vw, 3.5rem);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.95) 0%, rgba(76, 29, 149, 0.95) 100%);
      color: #fff;
      text-align: center;
    }

    header h1 {
      margin: 0 0 1rem;
      font-size: clamp(2.4rem, 6vw, 3.75rem);
    }

    header p {
      margin: 0 auto;
      max-width: 70ch;
      font-size: 1.15rem;
      line-height: 1.7;
    }

    nav {
      margin-top: 2rem;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    nav a {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(15, 23, 42, 0.35);
      padding: 0.7rem 1.2rem;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      color: #fff;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    nav a:hover {
      transform: translateY(-2px);
      background: rgba(15, 23, 42, 0.55);
    }

    main {
      padding: clamp(2rem, 6vw, 3.5rem);
      display: grid;
      gap: clamp(2rem, 4vw, 3rem);
    }

    .example {
      border-radius: 18px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: clamp(1.5rem, 4vw, 2.25rem);
      box-shadow: 0 15px 30px rgba(15, 23, 42, 0.08);
    }

    .example h2 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #4338ca;
    }

    .example p {
      color: #334155;
      margin-bottom: 1.5rem;
    }

    .code-block {
      background: #0b1120;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 1.25rem;
      font-family: "JetBrains Mono", "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.95rem;
      overflow-x: auto;
      margin-bottom: 1.5rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .toggle-group {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0.75rem;
      border-radius: 12px;
      background: rgba(79, 70, 229, 0.12);
      color: #4338ca;
      font-weight: 600;
    }

    .toggle-group label {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      cursor: pointer;
    }

    .toggle-group input[type="radio"] {
      accent-color: #7c3aed;
    }

    button {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 0.75rem 1.4rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(79, 70, 229, 0.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 15px 40px rgba(124, 58, 237, 0.35);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    input[type="file"] {
      font-size: 1rem;
    }

    .result {
      border-radius: 14px;
      background: #fff;
      border: 1px dashed rgba(79, 70, 229, 0.4);
      padding: 1.25rem;
      display: grid;
      gap: 1rem;
    }

    .result h3 {
      margin: 0;
      font-size: 1.2rem;
      color: #4c1d95;
    }

    .result img,
    .canvas-slot canvas {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .canvas-slot[hidden] {
      display: none;
    }

    .result img[hidden] {
      display: none;
    }

    .status {
      color: #4338ca;
      font-weight: 600;
    }

    .progress-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.95rem;
      color: #4338ca;
    }

    .progress-row[hidden] {
      display: none;
    }

    progress {
      width: clamp(160px, 25vw, 220px);
      height: 12px;
      accent-color: #7c3aed;
      background-color: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      overflow: hidden;
    }

    footer {
      text-align: center;
      padding: 2.5rem 1rem 3rem;
      color: rgba(15, 23, 42, 0.7);
      font-size: 0.95rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Interactive PNG Stitching</h1>
      <p>Experiment with modern browser helpers, progress callbacks, and canvas-aware workflows powered by image-stitch. Each demo shows the exact code you can drop into your own app.</p>
      <nav>
        <a href="index.html">üè† Overview</a>
        <a href="streaming.html">‚ö° Streaming demo</a>
        <a href="guides.html">üìò Guides &amp; API</a>
        <a href="https://github.com/jburnhams/Png-concat">üåê GitHub</a>
      </nav>
    </header>

    <main>
      <section class="example" id="horizontal">
        <h2>Horizontal sprite strip</h2>
        <p>Combine three pngsuite samples into a single row. Useful for spritesheets and UI icon strips.</p>
        <div class="code-block" data-code>
import { concatToBuffer } from "image-stitch";

const names = ["basi0g08.png", "basi2c08.png", "basi4a16.png"];
const buffers = await Promise.all(
  names.map((name) => fetch(`images/${name}`).then((res) => res.arrayBuffer()))
);
const output = await concatToBuffer({
  inputs: buffers,
  layout: { columns: 3 }
});
        </div>
        <div class="controls">
          <button data-run="horizontal">Run example</button>
          <span class="status" data-status="horizontal"></span>
        </div>
        <div class="result" data-result="horizontal">
          <h3>Result</h3>
          <img alt="Horizontal stitched output" />
          <div class="meta" data-meta="horizontal"></div>
        </div>
      </section>

      <section class="example" id="vertical">
        <h2>Vertical film strip</h2>
        <p>Let image-stitch handle varying heights automatically. Smaller inputs are padded with transparent pixels.</p>
        <div class="code-block" data-code>
import { concatToBuffer } from "image-stitch";

const names = ["basi2c08.png", "basi0g08.png"];
const buffers = await Promise.all(
  names.map((name) => fetch(`images/${name}`).then((res) => res.arrayBuffer()))
);
const output = await concatToBuffer({
  inputs: buffers,
  layout: { rows: 2 }
});
        </div>
        <div class="controls">
          <button data-run="vertical">Run example</button>
          <span class="status" data-status="vertical"></span>
        </div>
        <div class="result" data-result="vertical">
          <h3>Result</h3>
          <img alt="Vertical stitched output" />
          <div class="meta" data-meta="vertical"></div>
        </div>
      </section>

      <section class="example" id="grid">
        <h2>Auto-wrapping grid with progress</h2>
        <p>Limit the maximum width to wrap rows automatically. The <code>onProgress</code> callback fires after each tile finishes decoding so you can power loading indicators.</p>
        <div class="code-block" data-code>
import { concatToBuffer } from "image-stitch";

const output = await concatToBuffer({
  inputs: imageBuffers,
  layout: { width: 256 },
  onProgress(current, total) {
    console.log(`Decoded ${current} of ${total} tiles`);
  }
});
        </div>
        <div class="controls">
          <button data-run="grid">Run example</button>
          <span class="status" data-status="grid"></span>
        </div>
        <div class="progress-row" data-progress-wrapper="grid" hidden>
          <progress value="0" max="1" data-progress="grid"></progress>
          <span data-progress-label="grid">0 / 0</span>
        </div>
        <div class="result" data-result="grid">
          <h3>Result</h3>
          <img alt="Grid stitched output" />
          <div class="meta" data-meta="grid"></div>
        </div>
      </section>

      <section class="example" id="canvas">
        <h2>Canvas collage helper</h2>
        <p>Use <code>concatCanvases</code> to stitch existing <code>&lt;canvas&gt;</code> elements directly. Choose a Blob for downloads or render into another canvas for on-screen previews.</p>
        <div class="code-block" data-code>
import { concatCanvases } from "image-stitch/browser";

const stitched = await concatCanvases({
  canvases,
  layout: { rows: 2, columns: 2 },
  output: "canvas",
  onProgress(current, total) {
    console.log(`Rendered ${current}/${total}`);
  }
});
        </div>
        <div class="controls">
          <div class="toggle-group">
            <label>
              <input type="radio" name="canvas-output" value="blob" checked /> Blob preview
            </label>
            <label>
              <input type="radio" name="canvas-output" value="canvas" /> Canvas preview
            </label>
          </div>
          <button data-run="canvas">Stitch sample canvases</button>
          <span class="status" data-status="canvas"></span>
        </div>
        <div class="progress-row" data-progress-wrapper="canvas" hidden>
          <progress value="0" max="1" data-progress="canvas"></progress>
          <span data-progress-label="canvas">0 / 0</span>
        </div>
        <div class="result" data-result="canvas">
          <h3>Result</h3>
          <img alt="Canvas stitched output" hidden />
          <div class="canvas-slot" data-canvas-slot="canvas" hidden></div>
          <div class="meta" data-meta="canvas"></div>
        </div>
      </section>

      <section class="example" id="custom">
        <h2>Bring your own PNGs &amp; blobs</h2>
        <p>Drop in up to eight PNG files (16-bit color is supported!) and stitch them in your browser. Files are handled as <code>Blob</code> inputs‚Äîno need to convert to ArrayBuffers manually.</p>
        <div class="code-block" data-code>
import { concatToBuffer } from "image-stitch";

const files = Array.from(fileInput.files ?? []);
const output = await concatToBuffer({
  inputs: files,
  layout: { columns: 4, wrapBehavior: "wrap" }
});
        </div>
        <div class="controls">
          <input type="file" id="custom-files" accept="image/png" multiple />
          <button data-run="custom">Stitch selected files</button>
          <span class="status" data-status="custom"></span>
        </div>
        <div class="result" data-result="custom">
          <h3>Result</h3>
          <img alt="Custom stitched output" />
          <div class="meta" data-meta="custom"></div>
        </div>
      </section>

      <section class="example" id="node-stream">
        <h2>Streaming output in Node.js</h2>
        <p>Need a back-end friendly flow? Use <code>concatToStream</code> to pipe stitched PNG data straight into HTTP responses or file writers without buffering everything in memory.</p>
        <div class="code-block" data-code>
import { concatToStream } from "image-stitch";
import { createWriteStream } from "node:fs";
import { pipeline } from "node:stream/promises";

await pipeline(
  concatToStream({
    inputs: spriteParts,
    layout: { columns: 4 },
    onProgress(current, total) {
      console.info(`Completed ${current}/${total} tiles`);
    }
  }),
  createWriteStream("spritesheet.png")
);
        </div>
        <p>The async generator variant <code>concatStreaming(options)</code> works in any runtime that understands <code>for await...of</code>.</p>
      </section>
    </main>

    <footer>
      Need deeper dives? Explore the <a href="guides.html">Guides &amp; API reference</a> or visit <a href="https://github.com/jburnhams/Png-concat">GitHub</a> for advanced usage and source code.
    </footer>
  </div>

  <script type="module">
    const BUNDLE_URL = "./image-stitch.esm.js";
    const SAMPLE_PATH = "images/";

    const SAMPLE_MAP = {
      horizontal: ["basi0g08.png", "basi2c08.png", "basi4a16.png"],
      vertical: ["basi2c08.png", "basi0g08.png"],
      grid: ["basi0g08.png", "basi2c08.png", "basi4a16.png", "basi0g08.png"],
      canvas: ["basi0g08.png", "basi2c08.png", "basi4a16.png", "basi0g08.png"]
    };

    const LAYOUTS = {
      horizontal: { columns: 3 },
      vertical: { rows: 2 },
      grid: { width: 256 },
      canvas: { rows: 2, columns: 2 }
    };

    let modulePromise;

    async function ensureModule() {
      if (!modulePromise) {
        modulePromise = import(BUNDLE_URL);
      }
      return modulePromise;
    }

    const bufferCache = new Map();

    async function loadSampleBuffers(keys) {
      return Promise.all(
        keys.map(async (file) => {
          if (!bufferCache.has(file)) {
            const response = await fetch(`${SAMPLE_PATH}${file}`);
            if (!response.ok) {
              throw new Error(`Failed to load sample ${file}`);
            }
            bufferCache.set(file, await response.arrayBuffer());
          }
          return bufferCache.get(file);
        })
      );
    }

    async function bufferToCanvas(buffer) {
      const blob = new Blob([buffer], { type: "image/png" });

      if (typeof createImageBitmap === "function") {
        const bitmap = await createImageBitmap(blob);
        const canvas = document.createElement("canvas");
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext("2d");
        ctx?.drawImage(bitmap, 0, 0);
        bitmap.close?.();
        return canvas;
      }

      const url = URL.createObjectURL(blob);
      try {
        const img = await new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = () => resolve(image);
          image.onerror = (error) => reject(error);
          image.src = url;
        });
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx?.drawImage(img, 0, 0);
        return canvas;
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    async function loadSampleCanvases(keys) {
      const buffers = await loadSampleBuffers(keys);
      return Promise.all(buffers.map(bufferToCanvas));
    }

    function formatNumber(value) {
      return new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 }).format(value);
    }

    function formatKilobytes(bytes) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    }

    function clearPreview(id) {
      const image = document.querySelector(`[data-result="${id}"] img`);
      if (image?.dataset.url) {
        URL.revokeObjectURL(image.dataset.url);
        delete image.dataset.url;
      }
      if (image) {
        image.removeAttribute("src");
        image.hidden = false;
      }
      const canvasSlot = document.querySelector(`[data-canvas-slot="${id}"]`);
      if (canvasSlot) {
        canvasSlot.innerHTML = "";
        canvasSlot.hidden = true;
      }
    }

    function showBlob(id, blob, meta) {
      const image = document.querySelector(`[data-result="${id}"] img`);
      const canvasSlot = document.querySelector(`[data-canvas-slot="${id}"]`);
      if (!image) {
        return;
      }
      if (image.dataset.url) {
        URL.revokeObjectURL(image.dataset.url);
      }
      const url = URL.createObjectURL(blob);
      image.src = url;
      image.dataset.url = url;
      image.hidden = false;
      if (canvasSlot) {
        canvasSlot.innerHTML = "";
        canvasSlot.hidden = true;
      }
      const metaEl = document.querySelector(`[data-meta="${id}"]`);
      if (metaEl) {
        metaEl.textContent = meta;
      }
    }

    function showCanvas(id, canvas, meta) {
      const image = document.querySelector(`[data-result="${id}"] img`);
      const canvasSlot = document.querySelector(`[data-canvas-slot="${id}"]`);
      if (image?.dataset.url) {
        URL.revokeObjectURL(image.dataset.url);
        delete image.dataset.url;
      }
      if (image) {
        image.hidden = true;
      }
      if (canvasSlot) {
        canvasSlot.innerHTML = "";
        canvasSlot.hidden = false;
        canvasSlot.appendChild(canvas);
      }
      const metaEl = document.querySelector(`[data-meta="${id}"]`);
      if (metaEl) {
        metaEl.textContent = meta;
      }
    }

    function resetMeta(id) {
      const meta = document.querySelector(`[data-meta="${id}"]`);
      if (meta) {
        meta.textContent = "";
      }
    }

    function createProgressReporter(id, initialTotal) {
      const wrapper = document.querySelector(`[data-progress-wrapper="${id}"]`);
      const progress = document.querySelector(`[data-progress="${id}"]`);
      const label = document.querySelector(`[data-progress-label="${id}"]`);
      if (!progress) {
        return undefined;
      }
      if (wrapper instanceof HTMLElement) {
        wrapper.hidden = false;
      }
      progress.value = 0;
      progress.max = initialTotal ?? 1;
      progress.dataset.total = String(initialTotal ?? 1);
      if (label) {
        label.textContent = `0 / ${initialTotal ?? 1}`;
      }
      return (current, total) => {
        progress.max = total;
        progress.value = current;
        progress.dataset.total = String(total);
        if (label) {
          label.textContent = `${current} / ${total}`;
        }
      };
    }

    function finalizeProgress(id) {
      const progress = document.querySelector(`[data-progress="${id}"]`);
      const label = document.querySelector(`[data-progress-label="${id}"]`);
      if (!progress) {
        return;
      }
      const total = Number(progress.dataset.total ?? progress.max ?? 0);
      if (total > 0) {
        progress.value = total;
        if (label) {
          label.textContent = `${total} / ${total}`;
        }
      }
    }

    async function runExample(id) {
      const status = document.querySelector(`[data-status="${id}"]`);
      if (!status) return;
      const module = await ensureModule();
      const { concatToBuffer, concatCanvases } = module;

      status.textContent = "Preparing‚Ä¶";
      resetMeta(id);
      clearPreview(id);

      try {
        if (id === "custom") {
          const input = document.getElementById("custom-files");
          const files = Array.from((input?.files || [])).slice(0, 8);
          if (!files.length) {
            status.textContent = "Select one or more PNG files.";
            return;
          }
          status.textContent = `Processing ${files.length} file${files.length === 1 ? "" : "s"}‚Ä¶`;
          const stitched = await concatToBuffer({
            inputs: files,
            layout: { columns: 4, wrapBehavior: "wrap" }
          });
          status.textContent = "Rendering result‚Ä¶";
          const blob = new Blob([stitched], { type: "image/png" });
          showBlob(id, blob, `Output size: ${formatKilobytes(stitched.byteLength)}`);
          status.textContent = "Done!";
          return;
        }

        status.textContent = "Loading samples‚Ä¶";

        if (id === "canvas") {
          const canvases = await loadSampleCanvases(SAMPLE_MAP.canvas);
          const outputControl = document.querySelector('input[name="canvas-output"]:checked');
          const outputMode = outputControl?.value === "canvas" ? "canvas" : "blob";
          status.textContent = "Stitching canvases‚Ä¶";
          const onProgress = createProgressReporter(id, canvases.length);
          const result = await concatCanvases({
            canvases,
            layout: LAYOUTS.canvas,
            output: outputMode,
            ...(onProgress ? { onProgress } : {})
          });
          if (outputMode === "canvas") {
            finalizeProgress(id);
            status.textContent = "Done!";
            showCanvas(
              id,
              result,
              `Canvas size: ${formatNumber(result.width)} √ó ${formatNumber(result.height)}`
            );
          } else {
            finalizeProgress(id);
            status.textContent = "Rendering Blob‚Ä¶";
            const blob = result;
            showBlob(id, blob, `Blob size: ${formatKilobytes(blob.size)}`);
            status.textContent = "Done!";
          }
          return;
        }

        const sampleKeys = SAMPLE_MAP[id];
        if (!sampleKeys) {
          status.textContent = "Unknown example.";
          return;
        }
        const buffers = await loadSampleBuffers(sampleKeys);
        status.textContent = "Stitching‚Ä¶";
        const onProgress = id === "grid" ? createProgressReporter(id, buffers.length) : undefined;
        const stitched = await concatToBuffer({
          inputs: buffers,
          layout: LAYOUTS[id],
          ...(onProgress ? { onProgress } : {})
        });
        finalizeProgress(id);
        status.textContent = "Rendering result‚Ä¶";
        const blob = new Blob([stitched], { type: "image/png" });
        showBlob(id, blob, `Output size: ${formatKilobytes(stitched.byteLength)}`);
        status.textContent = "Done!";
      } catch (error) {
        console.error(error);
        status.textContent = error instanceof Error ? error.message : String(error);
      }
    }

    document.querySelectorAll('button[data-run]').forEach((button) => {
      button.addEventListener('click', () => runExample(button.dataset.run));
    });
  </script>
</body>
</html>
