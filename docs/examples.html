<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>image-stitch ‚Ä¢ Interactive Examples</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    body {
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #0f172a;
      padding: clamp(1.5rem, 4vw, 3rem);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.96);
      border-radius: 24px;
      box-shadow: 0 35px 90px rgba(76, 29, 149, 0.35);
      overflow: hidden;
    }

    header {
      padding: clamp(2rem, 6vw, 3.5rem);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.95) 0%, rgba(76, 29, 149, 0.95) 100%);
      color: #fff;
      text-align: center;
    }

    header h1 {
      margin: 0 0 1rem;
      font-size: clamp(2.4rem, 6vw, 3.75rem);
    }

    header p {
      margin: 0 auto;
      max-width: 70ch;
      font-size: 1.15rem;
      line-height: 1.7;
    }

    nav {
      margin-top: 2rem;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    nav a {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(15, 23, 42, 0.35);
      padding: 0.7rem 1.2rem;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      color: #fff;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    nav a:hover {
      transform: translateY(-2px);
      background: rgba(15, 23, 42, 0.55);
    }

    main {
      padding: clamp(2rem, 6vw, 3.5rem);
      display: grid;
      gap: clamp(2rem, 4vw, 3rem);
    }

    .example {
      border-radius: 18px;
      background: rgba(248, 250, 252, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: clamp(1.5rem, 4vw, 2.25rem);
      box-shadow: 0 15px 30px rgba(15, 23, 42, 0.08);
    }

    .example h2 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #4338ca;
    }

    .example p {
      color: #334155;
      margin-bottom: 1.5rem;
    }

    .code-block {
      background: #0b1120;
      color: #e2e8f0;
      border-radius: 12px;
      padding: 1.25rem;
      font-family: "JetBrains Mono", "Fira Code", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.95rem;
      overflow-x: auto;
      margin-bottom: 1.5rem;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    button {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 0.75rem 1.4rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(79, 70, 229, 0.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 15px 40px rgba(124, 58, 237, 0.35);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }

    input[type="file"] {
      font-size: 1rem;
    }

    .result {
      border-radius: 14px;
      background: #fff;
      border: 1px dashed rgba(79, 70, 229, 0.4);
      padding: 1.25rem;
      display: grid;
      gap: 1rem;
    }

    .result h3 {
      margin: 0;
      font-size: 1.2rem;
      color: #4c1d95;
    }

    .result img {
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .status {
      color: #4338ca;
      font-weight: 600;
    }

    .highlight-box {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(124, 58, 237, 0.18));
      border: 1px solid rgba(99, 102, 241, 0.35);
      border-radius: 16px;
      padding: clamp(1rem, 3vw, 1.5rem);
      display: grid;
      gap: 0.75rem;
      color: #3730a3;
      margin-bottom: 1.5rem;
    }

    .highlight-box h4 {
      margin: 0;
      font-size: 1.25rem;
    }

    .highlight-box p {
      margin: 0;
      color: #312e81;
    }

    .streaming-layout {
      display: grid;
      gap: clamp(1.5rem, 4vw, 2.5rem);
    }

    .streaming-panels {
      display: grid;
      gap: clamp(1.5rem, 4vw, 2rem);
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    .streaming-controls {
      background: rgba(237, 233, 254, 0.65);
      border: 1px solid rgba(79, 70, 229, 0.25);
      border-radius: 16px;
      padding: 1.5rem;
      display: grid;
      gap: 1.25rem;
    }

    .streaming-controls h4 {
      margin: 0;
      font-size: 1.1rem;
      color: #4c1d95;
    }

    .streaming-controls p {
      margin: 0;
      color: #4c1d95;
      font-size: 0.95rem;
    }

    .image-selector {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .image-option {
      background: rgba(255, 255, 255, 0.85);
      border-radius: 12px;
      border: 1px solid rgba(99, 102, 241, 0.25);
      padding: 1rem;
      text-align: center;
      display: grid;
      gap: 0.5rem;
      color: #4338ca;
    }

    .image-option img {
      width: 72px;
      height: 72px;
      object-fit: contain;
      margin: 0 auto;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #f8fafc;
    }

    .image-option label {
      font-size: 0.85rem;
      color: #4338ca;
    }

    .control-group {
      display: grid;
      gap: 0.35rem;
    }

    .control-group label {
      font-weight: 600;
      color: #4c1d95;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .control-group input[type="range"] {
      width: 100%;
      accent-color: #4f46e5;
    }

    .stats {
      background: rgba(255, 255, 255, 0.7);
      border-radius: 12px;
      border: 1px dashed rgba(99, 102, 241, 0.35);
      padding: 1rem;
      display: grid;
      gap: 0.5rem;
      color: #4338ca;
      font-size: 0.95rem;
    }

    .stats strong {
      color: #3730a3;
    }

    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .button-group button {
      flex: 1 1 180px;
    }

    .streaming-result {
      background: rgba(255, 255, 255, 0.85);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1.25rem;
      display: grid;
      gap: 0.75rem;
    }

    .streaming-result img {
      background: #f8fafc;
      border-radius: 12px;
      max-width: 100%;
    }

    .streaming-result .meta {
      color: #4c1d95;
      font-size: 0.95rem;
    }

    footer {
      text-align: center;
      padding: 2.5rem 1rem 3rem;
      color: rgba(15, 23, 42, 0.7);
      font-size: 0.95rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Interactive PNG Stitching</h1>
      <p>Experiment with horizontal strips, vertical reels, and responsive grids powered by image-stitch. Each demo shows the exact code you can drop into your own app.</p>
      <nav>
        <a href="index.html">üè† Overview</a>
        <a href="guides.html">üìò Guides &amp; API</a>
        <a href="https://github.com/jburnhams/Png-concat">üåê GitHub</a>
      </nav>
    </header>

    <main>
      <section class="example" id="horizontal">
        <h2>Horizontal sprite strip</h2>
        <p>Combine three pngsuite samples into a single row. Useful for spritesheets and UI icon strips.</p>
        <div class="code-block" data-code>
import { concatPngs } from "image-stitch";

const names = ["basi0g08.png", "basi2c08.png", "basi4a16.png"];
const buffers = await Promise.all(
  names.map((name) => fetch(`images/${name}`).then((res) => res.arrayBuffer()))
);
const output = await concatPngs({
  inputs: buffers,
  layout: { columns: 3 }
});
        </div>
        <div class="controls">
          <button data-run="horizontal">Run example</button>
          <span class="status" data-status="horizontal"></span>
        </div>
        <div class="result" data-result="horizontal">
          <h3>Result</h3>
          <img alt="Horizontal stitched output" />
          <div class="meta" data-meta="horizontal"></div>
        </div>
      </section>

      <section class="example" id="vertical">
        <h2>Vertical film strip</h2>
        <p>Let image-stitch handle varying heights automatically. Smaller inputs are padded with transparent pixels.</p>
        <div class="code-block" data-code>
import { concatPngs } from "image-stitch";

const names = ["basi2c08.png", "basi0g08.png"];
const buffers = await Promise.all(
  names.map((name) => fetch(`images/${name}`).then((res) => res.arrayBuffer()))
);
const output = await concatPngs({
  inputs: buffers,
  layout: { rows: 2 }
});
        </div>
        <div class="controls">
          <button data-run="vertical">Run example</button>
          <span class="status" data-status="vertical"></span>
        </div>
        <div class="result" data-result="vertical">
          <h3>Result</h3>
          <img alt="Vertical stitched output" />
          <div class="meta" data-meta="vertical"></div>
        </div>
      </section>

      <section class="example" id="grid">
        <h2>Auto-wrapping grid</h2>
        <p>Limit the maximum width to let image-stitch wrap rows automatically. Perfect for responsive contact sheets.</p>
        <div class="code-block" data-code>
import { concatPngs } from "image-stitch";

const names = ["basi0g08.png", "basi2c08.png", "basi4a16.png", "basi0g08.png"];
const buffers = await Promise.all(
  names.map((name) => fetch(`images/${name}`).then((res) => res.arrayBuffer()))
);
const output = await concatPngs({
  inputs: buffers,
  layout: { width: 256 }
});
        </div>
        <div class="controls">
          <button data-run="grid">Run example</button>
          <span class="status" data-status="grid"></span>
        </div>
        <div class="result" data-result="grid">
          <h3>Result</h3>
          <img alt="Grid stitched output" />
          <div class="meta" data-meta="grid"></div>
        </div>
      </section>

      <section class="example" id="streaming">
        <h2>Memory-efficient streaming generation</h2>
        <div class="highlight-box">
          <h4>Build massive outputs without breaking the browser</h4>
          <p>This demo mirrors a popular use case for image-stitch: <strong>streaming gigapixel PNGs directly to disk</strong>. The
            generator never loads a giant canvas‚Äîchunks are piped straight into the PNG encoder.</p>
          <p><strong>Try it:</strong> Mix thousands of tiles and export an enormous spritesheet. Even extreme dimensions are handled in the
            background without exhausting memory.</p>
        </div>

        <p>Select a pool of pngsuite images, pick the output dimensions, and let image-stitch stream the final PNG. Each run shuffles
          the selected inputs to create unique mosaics.</p>

        <div class="code-block" data-code>
const inputs = [];
for (let i = 0; i < totalImages; i++) {
  inputs.push(availableImages[randomIndex()]);
}

const result = await concatPngs({
  inputs,
  layout: { width }
});
// Generate PNGs up to 50_000 √ó 50_000 pixels with streaming!
        </div>

        <div class="streaming-layout">
          <div class="streaming-panels">
            <div class="streaming-controls">
              <div>
                <h4>Source images</h4>
                <p>Choose which 32√ó32 PNG tiles to randomize:</p>
              </div>

              <div class="image-selector">
                <div class="image-option">
                  <img src="images/basn2c08.png" alt="RGB 32x32" loading="lazy" />
                  <p>RGB 32√ó32</p>
                  <label>
                    <input type="checkbox" id="use-rgb" checked />
                    <span>Use this image</span>
                  </label>
                </div>
                <div class="image-option">
                  <img src="images/basn0g08.png" alt="Grayscale 32x32" loading="lazy" />
                  <p>Gray 32√ó32</p>
                  <label>
                    <input type="checkbox" id="use-gray" checked />
                    <span>Use this image</span>
                  </label>
                </div>
                <div class="image-option">
                  <img src="images/basn6a08.png" alt="RGBA 32x32" loading="lazy" />
                  <p>RGBA 32√ó32</p>
                  <label>
                    <input type="checkbox" id="use-rgba" checked />
                    <span>Use this image</span>
                  </label>
                </div>
                <div class="image-option">
                  <img src="images/basn4a08.png" alt="Gray+Alpha 32x32" loading="lazy" />
                  <p>Gray+A 32√ó32</p>
                  <label>
                    <input type="checkbox" id="use-graya" checked />
                    <span>Use this image</span>
                  </label>
                </div>
              </div>

              <div>
                <h4>Output configuration</h4>
              </div>

              <div class="control-group">
                <label for="output-width">Width (pixels): <span id="width-value">1,000</span></label>
                <input type="range" id="output-width" min="32" max="50000" value="1000" step="32" />
              </div>

              <div class="control-group">
                <label for="output-height">Height (pixels): <span id="height-value">1,000</span></label>
                <input type="range" id="output-height" min="32" max="50000" value="1000" step="32" />
              </div>

              <div id="stats6" class="stats">
                <p><strong>Output dimensions:</strong> <span id="output-dimensions">1,000 √ó 1,000 px</span></p>
                <p><strong>Estimated input tiles:</strong> <span id="estimated-images">~976</span></p>
                <p><strong>Estimated file size:</strong> <span id="estimated-size">~1‚Äì3 MB</span></p>
              </div>
            </div>

            <div class="streaming-controls">
              <div class="button-group">
                <button type="button" data-streaming="preview">Preview image</button>
                <button type="button" data-streaming="download">Download image</button>
              </div>
              <span class="status" id="streaming-status"></span>
              <div class="streaming-result" id="streaming-result">
                <h3>Preview</h3>
                <img alt="Streaming generation preview" />
                <div class="meta" id="streaming-meta">Generate an image to view details.</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="example" id="custom">
        <h2>Bring your own PNGs</h2>
        <p>Drop in up to eight PNG files (16-bit color is supported!) and stitch them in your browser. No uploads‚Äîeverything runs locally.</p>
        <div class="code-block" data-code>
import { concatPngs } from "image-stitch";

const files = Array.from(fileInput.files ?? []);
const buffers = await Promise.all(files.map(file => file.arrayBuffer()));
const output = await concatPngs({
  inputs: buffers,
  layout: { columns: 4, wrapBehavior: "wrap" }
});
        </div>
        <div class="controls">
          <input type="file" id="custom-files" accept="image/png" multiple />
          <button data-run="custom">Stitch selected files</button>
          <span class="status" data-status="custom"></span>
        </div>
        <div class="result" data-result="custom">
          <h3>Result</h3>
          <img alt="Custom stitched output" />
          <div class="meta" data-meta="custom"></div>
        </div>
      </section>
    </main>

    <footer>
      Need deeper dives? Explore the <a href="guides.html">Guides &amp; API reference</a> or visit <a href="https://github.com/jburnhams/Png-concat">GitHub</a> for advanced usage and source code.
    </footer>
  </div>

  <script type="module">
    const BUNDLE_URL = "./image-stitch.esm.js";
    const SAMPLE_PATH = "images/";

    const SAMPLE_MAP = {
      horizontal: ["basi0g08.png", "basi2c08.png", "basi4a16.png"],
      vertical: ["basi2c08.png", "basi0g08.png"],
      grid: ["basi0g08.png", "basi2c08.png", "basi4a16.png", "basi0g08.png"]
    };

    const LAYOUTS = {
      horizontal: { columns: 3 },
      vertical: { rows: 2 },
      grid: { width: 256 }
    };

    const STREAMING_SOURCES = [
      { id: "use-rgb", file: "basn2c08.png" },
      { id: "use-gray", file: "basn0g08.png" },
      { id: "use-rgba", file: "basn6a08.png" },
      { id: "use-graya", file: "basn4a08.png" }
    ];

    const TILE_SIZE = 32;

    let concatPngs;

    const streamingCache = new Map();

    async function ensureLibrary() {
      if (!concatPngs) {
        const module = await import(BUNDLE_URL);
        concatPngs = module.concatPngs;
      }
      return concatPngs;
    }

    async function loadSampleBuffers(keys) {
      return Promise.all(
        keys.map(async (file) => {
          const response = await fetch(`${SAMPLE_PATH}${file}`);
          if (!response.ok) {
            throw new Error(`Failed to load sample ${file}`);
          }
          return response.arrayBuffer();
        })
      );
    }

    function getSliderValue(el) {
      return el ? Number.parseInt(el.value, 10) : 0;
    }

    function formatNumber(value) {
      return value.toLocaleString();
    }

    function estimateFileSize(width, height) {
      const bytes = width * height * 4;
      const mb = bytes / (1024 * 1024);
      if (mb < 1) return "< 1 MB";
      if (mb < 3) return "~1‚Äì3 MB";
      return `~${mb.toFixed(1)} MB`;
    }

    function updateStreamingStats() {
      const widthInput = document.getElementById("output-width");
      const heightInput = document.getElementById("output-height");
      const width = getSliderValue(widthInput);
      const height = getSliderValue(heightInput);
      const tileArea = TILE_SIZE * TILE_SIZE;
      const totalTiles = Math.max(1, Math.ceil((width * height) / tileArea));

      const widthValue = document.getElementById("width-value");
      const heightValue = document.getElementById("height-value");
      const dimensions = document.getElementById("output-dimensions");
      const estimatedImages = document.getElementById("estimated-images");
      const estimatedSize = document.getElementById("estimated-size");

      if (widthValue) widthValue.textContent = formatNumber(width);
      if (heightValue) heightValue.textContent = formatNumber(height);
      if (dimensions) dimensions.textContent = `${formatNumber(width)} √ó ${formatNumber(height)} px`;
      if (estimatedImages) estimatedImages.textContent = `~${formatNumber(totalTiles)}`;
      if (estimatedSize) estimatedSize.textContent = estimateFileSize(width, height);
    }

    function getStreamingSelection() {
      return STREAMING_SOURCES.filter((option) => {
        const checkbox = document.getElementById(option.id);
        return checkbox ? checkbox.checked : false;
      });
    }

    async function loadStreamingBuffers(selections) {
      return Promise.all(
        selections.map(async ({ file }) => {
          if (!streamingCache.has(file)) {
            const response = await fetch(`${SAMPLE_PATH}${file}`);
            if (!response.ok) {
              throw new Error(`Failed to load sample ${file}`);
            }
            streamingCache.set(file, await response.arrayBuffer());
          }
          return streamingCache.get(file);
        })
      );
    }

    function clearStreamingPreview() {
      const resultEl = document.querySelector("#streaming-result img");
      if (resultEl && resultEl.dataset.url) {
        URL.revokeObjectURL(resultEl.dataset.url);
        delete resultEl.dataset.url;
        resultEl.removeAttribute("src");
      }
    }

    async function runStreamingExample({ download }) {
      const status = document.getElementById("streaming-status");
      const resultImg = document.querySelector("#streaming-result img");
      const meta = document.getElementById("streaming-meta");
      const width = getSliderValue(document.getElementById("output-width"));
      const height = getSliderValue(document.getElementById("output-height"));

      if (!status || !resultImg || !meta) return;

      const selections = getStreamingSelection();
      if (!selections.length) {
        status.textContent = "Select at least one source image.";
        return;
      }

      try {
        status.textContent = "Preparing tiles‚Ä¶";
        const buffers = await loadStreamingBuffers(selections);
        const concat = await ensureLibrary();
        const tileArea = TILE_SIZE * TILE_SIZE;
        const totalTiles = Math.max(1, Math.ceil((width * height) / tileArea));
        const inputs = Array.from({ length: totalTiles }, () => {
          const index = Math.floor(Math.random() * buffers.length);
          return buffers[index];
        });

        status.textContent = "Stitching‚Ä¶";
        const stitched = await concat({
          inputs,
          layout: { width, wrapBehavior: "wrap" }
        });

        const blob = new Blob([stitched], { type: "image/png" });
        const url = URL.createObjectURL(blob);

        if (download) {
          const link = document.createElement("a");
          link.href = url;
          link.download = `image-stitch-${width}x${height}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          status.textContent = "Download started.";
          URL.revokeObjectURL(url);
        } else {
          clearStreamingPreview();
          resultImg.src = url;
          resultImg.dataset.url = url;
          meta.textContent = `Output size: ${(stitched.byteLength / (1024 * 1024)).toFixed(2)} MB`;
          status.textContent = `Generated ${formatNumber(totalTiles)} tiles.`;
        }
      } catch (error) {
        console.error(error);
        status.textContent = error instanceof Error ? error.message : String(error);
      }
    }

    function registerStreamingHandlers() {
      const widthInput = document.getElementById("output-width");
      const heightInput = document.getElementById("output-height");
      const checkboxes = document.querySelectorAll(".image-selector input[type='checkbox']");
      const status = document.getElementById("streaming-status");
      const meta = document.getElementById("streaming-meta");

      widthInput?.addEventListener("input", () => {
        updateStreamingStats();
        clearStreamingPreview();
        if (status) status.textContent = "";
        if (meta) meta.textContent = "Generate an image to view details.";
      });
      heightInput?.addEventListener("input", () => {
        updateStreamingStats();
        clearStreamingPreview();
        if (status) status.textContent = "";
        if (meta) meta.textContent = "Generate an image to view details.";
      });
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          updateStreamingStats();
          clearStreamingPreview();
          if (status) status.textContent = "";
          if (meta) meta.textContent = "Generate an image to view details.";
        });
      });

      document.querySelectorAll("[data-streaming]").forEach((button) => {
        button.addEventListener("click", () =>
          runStreamingExample({ download: button.dataset.streaming === "download" })
        );
      });

      updateStreamingStats();
    }

    async function runExample(id) {
      const status = document.querySelector(`[data-status="${id}"]`);
      const resultEl = document.querySelector(`[data-result="${id}"] img`);
      const meta = document.querySelector(`[data-meta="${id}"]`);
      if (!status || !resultEl || !meta) return;

      try {
        status.textContent = "Preparing‚Ä¶";
        meta.textContent = "";
        const concat = await ensureLibrary();
        status.textContent = "Loading samples‚Ä¶";
        let buffers;
        if (id === "custom") {
          const input = document.getElementById("custom-files");
          const files = Array.from(input.files || []).slice(0, 8);
          if (!files.length) {
            status.textContent = "Select one or more PNG files.";
            return;
          }
          status.textContent = `Processing ${files.length} file${files.length === 1 ? "" : "s"}‚Ä¶`;
          buffers = await Promise.all(files.map((file) => file.arrayBuffer()));
        } else {
          buffers = await loadSampleBuffers(SAMPLE_MAP[id]);
        }

        status.textContent = "Stitching‚Ä¶";
        const layout = id === "custom" ? { columns: 4, wrapBehavior: "wrap" } : LAYOUTS[id];
        const stitched = await concat({ inputs: buffers, layout });
        const blob = new Blob([stitched], { type: "image/png" });
        const url = URL.createObjectURL(blob);
        if (resultEl.dataset.url) {
          URL.revokeObjectURL(resultEl.dataset.url);
        }
        resultEl.src = url;
        resultEl.dataset.url = url;
        meta.textContent = `Output size: ${(stitched.byteLength / 1024).toFixed(2)} KB`;
        status.textContent = "Done!";
      } catch (error) {
        console.error(error);
        status.textContent = error.message;
      }
    }

    document.querySelectorAll("button[data-run]").forEach((button) => {
      button.addEventListener("click", () => runExample(button.dataset.run));
    });

    registerStreamingHandlers();
  </script>
</body>
</html>
